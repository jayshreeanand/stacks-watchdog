const { Web3 } = require('web3');
const axios = require('axios');
const { ethers } = require('ethers');
require('dotenv').config();

// Common vulnerability patterns in smart contracts
const VULNERABILITY_PATTERNS = {
  reentrancy: {
    pattern: /(\.\s*call\s*\{.*?\}.*?;)(?!.*require\(.*?\))/gs,
    description: 'Potential reentrancy vulnerability: External call without checks',
    severity: 'HIGH'
  },
  uncheckedSend: {
    pattern: /(\.\s*send\s*\(.*?\))(?!.*require\(.*?\))/gs,
    description: 'Unchecked send: Missing return value check',
    severity: 'MEDIUM'
  },
  txOrigin: {
    pattern: /tx\.origin(?!.*msg\.sender)/gs,
    description: 'Using tx.origin for authorization: Phishing vulnerability',
    severity: 'HIGH'
  },
  integerOverflow: {
    pattern: /\+\+(?!.*SafeMath)/gs,
    description: 'Potential integer overflow: Consider using SafeMath',
    severity: 'MEDIUM'
  },
  selfDestruct: {
    pattern: /selfdestruct|suicide/gs,
    description: 'Self-destruct function: Can be used to destroy contract',
    severity: 'HIGH'
  },
  delegateCall: {
    pattern: /delegatecall/gs,
    description: 'Delegatecall usage: Can be dangerous if not properly secured',
    severity: 'HIGH'
  },
  randomNumberGen: {
    pattern: /block\.(timestamp|number|difficulty)|now/gs,
    description: 'Insecure randomness: Using block properties for randomness',
    severity: 'MEDIUM'
  },
  unprotectedFunction: {
    pattern: /function\s+\w+\s*\([^)]*\)\s*public(?!\s+view|\s+pure)(?!.*onlyOwner|require\(|assert\()/gs,
    description: 'Unprotected function: Missing access control',
    severity: 'MEDIUM'
  }
};

class VulnerabilityScanner {
  constructor(provider) {
    if (!provider) {
      throw new Error('Provider URL is required');
    }
    this.provider = provider;
    
    try {
      // Initialize Web3 with HTTP provider
      this.web3 = new Web3(provider);
      
      // Initialize Ethers provider
      this.ethersProvider = new ethers.JsonRpcProvider(provider);
      
      this.scanResults = {};
      this.isScanning = false;
      this.latestBlock = 0;
    } catch (error) {
      console.error('Error initializing providers:', error);
      throw error;
    }
  }

  async initialize() {
    try {
      console.log('Testing connection to Stacks network...');
      
      // Test Web3 connection
      const web3Network = await this.web3.eth.getChainId();
      console.log(`Connected to network ID: ${web3Network}`);
      
      // Test Ethers connection
      this.latestBlock = await this.ethersProvider.getBlockNumber();
      console.log(`Current block number: ${this.latestBlock}`);
      
      return true;
    } catch (error) {
      console.error('Failed to initialize scanner:', error);
      return false;
    }
  }

  async startRealTimeScanning(callback) {
    if (this.isScanning) {
      return false;
    }

    this.isScanning = true;
    console.log('Starting real-time vulnerability scanning...');

    // Subscribe to new blocks
    this.ethersProvider.on('block', async (blockNumber) => {
      try {
        console.log(`New block detected: ${blockNumber}`);
        const block = await this.ethersProvider.getBlock(blockNumber, true);
        
        if (block && block.transactions) {
          for (const tx of block.transactions) {
            // Only process contract creation transactions
            if (!tx.to) {
              await this.scanTransaction(tx, callback);
            }
          }
        }
      } catch (error) {
        console.error(`Error processing block ${blockNumber}:`, error);
      }
    });

    return true;
  }

  stopScanning() {
    this.isScanning = false;
    this.ethersProvider.removeAllListeners('block');
    console.log('Vulnerability scanning stopped');
    return true;
  }

  async scanTransaction(tx, callback) {
    try {
      // Get transaction receipt to check if it was successful
      const receipt = await this.ethersProvider.getTransactionReceipt(tx.hash);
      
      if (!receipt || receipt.status === 0) {
        return; // Skip failed transactions
      }

      // Get contract address from receipt
      const contractAddress = receipt.contractAddress;
      if (!contractAddress) {
        return; // Not a contract creation transaction
      }

      console.log(`Scanning new contract at ${contractAddress}`);

      // Get contract code
      const code = await this.ethersProvider.getCode(contractAddress);
      
      // Get source code if available (using Etherscan-like API)
      let sourceCode = '';
      try {
        // This would typically use an explorer API like Etherscan
        // For demo purposes, we'll use a placeholder
        sourceCode = await this.getContractSourceCode(contractAddress);
      } catch (error) {
        console.log(`Could not get source code for ${contractAddress}, using bytecode analysis only`);
      }

      // Scan for vulnerabilities
      const vulnerabilities = this.scanForVulnerabilities(sourceCode || code, contractAddress);
      
      // Store results
      this.scanResults[contractAddress] = {
        address: contractAddress,
        creationTx: tx.hash,
        timestamp: new Date().toISOString(),
        vulnerabilities
      };

      // Notify through callback
      if (callback && typeof callback === 'function') {
        callback({
          type: 'new_scan',
          data: this.scanResults[contractAddress]
        });
      }

    } catch (error) {
      console.error(`Error scanning transaction ${tx.hash}:`, error);
    }
  }

  async getContractSourceCode(address) {
    // In a real implementation, this would call an API like Etherscan
    // For demo purposes, we'll return a mock response
    return `
      contract VulnerableContract {
        mapping(address => uint) private balances;
        
        function withdraw(uint amount) public {
          require(balances[msg.sender] >= amount);
          
          // Vulnerable to reentrancy
          (bool success, ) = msg.sender.call{value: amount}("");
          
          balances[msg.sender] -= amount;
        }
        
        function getRandomNumber() public view returns (uint) {
          // Insecure randomness
          return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty)));
        }
      }
    `;
  }

  scanForVulnerabilities(code, address) {
    const vulnerabilities = [];

    // Check for each vulnerability pattern
    for (const [type, info] of Object.entries(VULNERABILITY_PATTERNS)) {
      const matches = [...code.matchAll(info.pattern)];
      
      if (matches.length > 0) {
        vulnerabilities.push({
          type,
          description: info.description,
          severity: info.severity,
          occurrences: matches.length,
          contractAddress: address
        });
      }
    }

    return vulnerabilities;
  }

  async scanSpecificContract(address, callback) {
    try {
      console.log(`Scanning specific contract at ${address}`);
      
      // Get contract code
      const code = await this.ethersProvider.getCode(address);
      
      if (code === '0x' || code === '0x0') {
        throw new Error('Not a contract address');
      }
      
      // Get source code if available
      let sourceCode = '';
      try {
        sourceCode = await this.getContractSourceCode(address);
      } catch (error) {
        console.log(`Could not get source code for ${address}, using bytecode analysis only`);
      }

      // Scan for vulnerabilities
      const vulnerabilities = this.scanForVulnerabilities(sourceCode || code, address);
      
      // Store results
      this.scanResults[address] = {
        address,
        timestamp: new Date().toISOString(),
        vulnerabilities
      };

      // Notify through callback
      if (callback && typeof callback === 'function') {
        callback({
          type: 'new_scan',
          data: this.scanResults[address]
        });
      }

      return this.scanResults[address];
    } catch (error) {
      console.error(`Error scanning contract ${address}:`, error);
      throw error;
    }
  }

  getResults() {
    return this.scanResults;
  }
}

module.exports = VulnerabilityScanner; 