const express = require('express');
const router = express.Router();
const VulnerabilityScanner = require('../utils/vulnerabilityScanner');
const { ethers } = require('ethers');

// Initialize the scanner with the provider from environment variables
let scanner = null;

// Sample vulnerable contracts for demo purposes
const SAMPLE_VULNERABLE_CONTRACTS = [
  {
    address: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.usda-token',
    name: 'USDA Stablecoin',
    description: 'Stablecoin contract'
  },
  {
    address: 'SP3K8BC0PPEVCV7NZ6QSRWPQ2JE9E5B6N3PA0KBR9.token-amm',
    name: 'AMM Exchange',
    description: 'DEX contract'
  },
  {
    address: 'SP2C2YFP12AJZB4MABJBAJ55XECVS7E4PMMZ89YZR.wrapped-stx-token',
    name: 'Wrapped STX',
    description: 'Wrapped STX contract'
  },
  {
    address: 'SP2H8PY27SEZ03MWRKS5XABZYQN17ETGQS3527SA5.newyorkcitycoin-token',
    name: 'NYC Coin',
    description: 'City token'
  },
  {
    address: 'SP1Z92MPDQEWZXW36VX71Q25HKF5K2EPCJ304F275.tokensoft-token-v2',
    name: 'TokenSoft Token',
    description: 'TokenSoft contract'
  }
];

// Initialize the scanner
router.get('/initialize', async (req, res) => {
  try {
    // Use Stacks testnet RPC URL from environment variables
    const provider = process.env.STACK_TESTNET_RPC_URL;
    if (!provider) {
      throw new Error('STACK_TESTNET_RPC_URL not set in environment variables');
    }
    
    scanner = new VulnerabilityScanner(provider);
    const initialized = await scanner.initialize();
    
    if (initialized) {
      res.json({ success: true, message: 'Vulnerability scanner initialized successfully with Stacks testnet' });
    } else {
      res.status(500).json({ success: false, message: 'Failed to initialize vulnerability scanner' });
    }
  } catch (error) {
    console.error('Error initializing scanner:', error);
    res.status(500).json({ success: false, message: 'Error initializing scanner', error: error.message });
  }
});

// Start real-time scanning
router.post('/start-scanning', async (req, res) => {
  try {
    if (!scanner) {
      return res.status(400).json({ success: false, message: 'Scanner not initialized. Call /initialize first.' });
    }
    
    const started = await scanner.startRealTimeScanning((data) => {
      // This callback will be used with Socket.io to send real-time updates
      // We'll implement this in the main server file
    });
    
    if (started) {
      res.json({ success: true, message: 'Real-time vulnerability scanning started' });
    } else {
      res.status(400).json({ success: false, message: 'Scanner is already running' });
    }
  } catch (error) {
    console.error('Error starting scanner:', error);
    res.status(500).json({ success: false, message: 'Error starting scanner', error: error.message });
  }
});

// Stop scanning
router.post('/stop-scanning', (req, res) => {
  try {
    if (!scanner) {
      return res.status(400).json({ success: false, message: 'Scanner not initialized' });
    }
    
    const stopped = scanner.stopScanning();
    
    if (stopped) {
      res.json({ success: true, message: 'Vulnerability scanning stopped' });
    } else {
      res.status(400).json({ success: false, message: 'Scanner is not running' });
    }
  } catch (error) {
    console.error('Error stopping scanner:', error);
    res.status(500).json({ success: false, message: 'Error stopping scanner', error: error.message });
  }
});

// Scan a specific contract
router.post('/scan-contract', async (req, res) => {
  try {
    const { address } = req.body;
    
    if (!address) {
      return res.status(400).json({ success: false, message: 'Contract address is required' });
    }
    
    if (!scanner) {
      return res.status(400).json({ success: false, message: 'Scanner not initialized. Call /initialize first.' });
    }
    
    // For demo purposes, we'll return mock data for sample contracts
    if (SAMPLE_VULNERABLE_CONTRACTS.some(c => c.address.toLowerCase() === address.toLowerCase())) {
      // Generate mock vulnerabilities for demo
      const mockResult = generateMockVulnerabilities(address);
      return res.json({ success: true, data: mockResult });
    }
    
    // Real scanning for other addresses
    const result = await scanner.scanSpecificContract(address);
    res.json({ success: true, data: result });
  } catch (error) {
    console.error('Error scanning contract:', error);
    res.status(500).json({ success: false, message: 'Error scanning contract', error: error.message });
  }
});

// Get all scan results
router.get('/results', (req, res) => {
  try {
    if (!scanner) {
      return res.status(400).json({ success: false, message: 'Scanner not initialized' });
    }
    
    const results = scanner.getResults();
    res.json({ success: true, data: results });
  } catch (error) {
    console.error('Error getting results:', error);
    res.status(500).json({ success: false, message: 'Error getting results', error: error.message });
  }
});

// Get sample contracts for demo
router.get('/sample-contracts', (req, res) => {
  res.json({ success: true, data: SAMPLE_VULNERABLE_CONTRACTS });
});

// Helper function to generate mock vulnerabilities for demo
function generateMockVulnerabilities(address) {
  const vulnerabilityTypes = [
    {
      type: 'reentrancy',
      description: 'Potential reentrancy vulnerability: External call without checks',
      severity: 'HIGH'
    },
    {
      type: 'uncheckedSend',
      description: 'Unchecked send: Missing return value check',
      severity: 'MEDIUM'
    },
    {
      type: 'txOrigin',
      description: 'Using tx.origin for authorization: Phishing vulnerability',
      severity: 'HIGH'
    },
    {
      type: 'integerOverflow',
      description: 'Potential integer overflow: Consider using SafeMath',
      severity: 'MEDIUM'
    },
    {
      type: 'randomNumberGen',
      description: 'Insecure randomness: Using block properties for randomness',
      severity: 'MEDIUM'
    }
  ];
  
  // Randomly select 1-3 vulnerabilities
  const numVulnerabilities = Math.floor(Math.random() * 3) + 1;
  const selectedVulnerabilities = [];
  
  for (let i = 0; i < numVulnerabilities; i++) {
    const randomIndex = Math.floor(Math.random() * vulnerabilityTypes.length);
    const vulnerability = { ...vulnerabilityTypes[randomIndex] };
    vulnerability.occurrences = Math.floor(Math.random() * 3) + 1;
    vulnerability.contractAddress = address;
    selectedVulnerabilities.push(vulnerability);
    
    // Remove this vulnerability from the array to avoid duplicates
    vulnerabilityTypes.splice(randomIndex, 1);
    
    if (vulnerabilityTypes.length === 0) break;
  }
  
  return {
    address,
    timestamp: new Date().toISOString(),
    vulnerabilities: selectedVulnerabilities
  };
}

module.exports = router; 